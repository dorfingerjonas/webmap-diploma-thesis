\section{Versionierung}
\setauthor{Jonas Dorfinger}
Der Begriff Versionierung beschreibt im Allgemeinen einen Prozess welcher zur Dokumentation von Änderungen an Dokumenten oder Dateien stattfindet.
Nach jeder Änderung wird im System eine aktuelle Version abgespeichert und mit einer eindeutigen Versionsnummer versehen.
Die Versionsnummer wird meist automatisch durch das Versionierungstool vergeben.
Zusätzlich wird auch gespeichert, wer welche Einträge wann und wo gemacht hat, so werden Änderungen transparent mitprotokolliert.
Eine der wichtigsten Vorteile einer Versionierung ist jedoch die Funktion, dass man alte Ständ von Dateien wiederherstellen kann.
Eine Versionsverwaltungssoftware kann auch die gleichzeitigen Zugriffe auf eine Datei von mehrere Personen koordinieren.
Versionierung ist nicht nur in der Softwareentwicklungs Branche Standard, sondern auch in etlichen weiteren Bereichen stark
verbreitet.

\subsection{automatische vs. manuelle Versionierung}
\setauthor{Jonas Dorfinger}
Wenn während dem Schreiben einer Arbeit Sicherheitskopien anlegt und diese mit zum Beispiel "arbeit-neu",
"arbeit-fertig" oder "arbeit-fertig2" benennt werden, dann ist das nichts anderes als eine manuelle Versionierung, weil auch hier
eine eindeutige Versionsnummer für jede Datei vergeben wurde.
Das birgt aber auch große Risiken, da eine manuelle Versionierung viel Zeit und Disziplin erfordert und immer die Gefahr
besteht, dass man eine wichtige Version überschreibt.
Die meisten Probleme werden von der automatischen Versionierung gelöst.
Bei dieser Variante werden automatisch, wenn man einen Stand als "fertig" markiert, diese mit einer Versionsnummer versehen
und im Archiv schreibgeschützt abgelegt.
Dadurch hat man die Risiken der manuellen Versionierung auf ein Minimum reduziert~\cite{versionierung}.

\subsection{git}
\setauthor{Jonas Dorfinger}
git ist \emph{das} Versionierungssystem in der Softwareentwicklung.
Es wurde designt um kleine aber auch extrem große und komplexe Projekte effizient zu verwalten.
Grundsätzlich als CLI (Command Line Interface) konzeptioniert, gibt es mittlerweile auch etliche Grafische Implementierungen,
um git interaktiver und intuitiver zu gestalten.
Laut einer Umfrage von Stackoverflow nutzen mehr als 87\% der Entwickler weltweit git~\cite{stackoverflow-git-survey}.

\subsubsection{Der git Workflow}
Der git Workflow beschreibt die effizienteste Arbeitsweise mit git.
Dabei gibt es vier Stufen zwischen denen mit verschiedenen Konsolen Befehlen gewechselt werden kann.

\paragraph{1. Remote Repository}
Das Remote Repository befindet sich auf einem externen Server (zum Beispiel Github Server~\ref{subsec:github}).
Mit einem einfache \emph{git clone} Befehl in der Konsole, kann man das Repository klonen und somit ein lokales Repository erstellen.
Auf dieses Archiv können mehrere Personen zugreifen und so gemeinsam an einem Projekt arbeiten.

\paragraph{2. Lokales Repository}
Das Lokale Repository ist eine Kopie der Version im Remote Repository, mit dem Unterschied, dass die lokalen Änderungen in
diesem Repository gesammelt werden und erst durch den Befehl \emph{git push} wieder zurück ins Remote Repository gelangen.

\paragraph{3. Staging Area}
In der Staging Area sind alle lokal modifizierten Files, welche für den nächsten Commit auserwählt sind, gesammelt.
Durch den Befehl \emph{git commit -m <message>} gelangen ausgewählte Änderungen in des lokale Repository.
Ein Commit repräsentiert dabei eine Version des Programmes, welche mit einer eindeutigen Nummer im System gespeichert wird.

\paragraph{4. Working Directory}
Im Working Directory wird tatsächlich programmiert, alle Änderungen der Files werden hier durchgeführt.
Mit dem Befehl \emph{git add <filename>} können einzelne Files gezielt in die Staging Area verschoben werden um diese
dann anschließend ins lokale Repository zu committen.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.4]{pics/git-workflow}
    \caption{git workflow~\cite{git-workflow}}
    \label{fig:git-workflow}
\end{figure}

\cite{git-workflow}

\subsection{Semantische Versionierung}
\label{subsec:semantic-versioning}
Eine semantische Versionsnummer besteht aus drei Teilen:

\begin{center}
    \centering{MAJOR.MINOR.PATCH}
\end{center}

Und sollen nach Änderungen in der entsprechenden Kategorie in einser Schritten erhöht werden.

\textbf{MAJOR}
Wenn API Änderungen durchgeführt werden, welche die API mit der Vorgängerversion inkompatibel machen
\linebreak

\textbf{MINOR}
Wenn Funktionalität hinzugefügt wird, welche mit älteren Versionen noch kompatibel sind
\linebreak

\textbf{PATCH}
Wenn kleine Bug fixes durchgeführt werden, welche auch mit älteren Versionen kompatibel sind
\linebreak

Zusätzlich können auch labels für \emph{pre-release} oder \emph{build metadata} angegeben werden:

\begin{center}
    \centering{MAJOR.MINOR.PATCH format}
\end{center}

\cite{semantische-versionierung}

\subsection{GitHub}\label{subsec:github}
GitHub Inc. ist ein amerikanisches gewinnorientiertes Softwareunternehmen, welches git Repositories in der Cloud anbietet,
also das Remote Repository.
Dadurch können Privatpersonen aber auch große Unternehmen und Konzerne ganz leicht git als Versionierungstool verwenden.
Durch viele Features von GitHub wird das arbeiten mit git so stark erleichtert, dass auch Anfänger bereits sehr profesionell
mit git arbeiten und lernen können.
Normalerweise verwendet man git mit der Kommandozeile des jeweiligen Betriebssystemes, was hohes technisches Verständnis voraussetzt.
Man kann einen kostenlosen Account erstellen und gratis Repositories anlegen und verwenden,
deshalb ist Github in der Open-Source Community sehr stark verbreitet.
Doch mittlerweile kann diese Software mehr als "nur" Projekte zu versionieren.
Es gibt project-tracking-tools (GitHub Projects, Issues, Milestones, Labels, etc.), Pipelines für Continues Integration and Delivery,
gratis Website Hosting und noch vieles mehr~\cite{github-features}.

Es gibt aber auch andere Programme welche zu GitHub gehören, zum einen ist es \emph{Atom}, ein kostenloser und Open-Source Editor für Entwickler.
Weiters gibt es zum Beispiel auch \emph{Electron}, das ist ebenfalls ein Open-Source JavaScript Framework um Web-Anwendungen zu Desktopanwendungen zu machen.

Unternehmen können kostenpflichtige Organisationen anlegen, um alle Repositories einer Firma gesammelt an einem Ort zu verwalten.
Dazu gibt es wieder etliche Features welche die Sicherheit, Rollen und vieles mehr betreffen.

Seit 2018 gehört GitHub zu Microsoft, welche für die Übernahme \$7,5 Milliarden US-Dollar auf den Tisch gelegt haben~\cite{microsoft-acquires-github}.


\section{Projektkoordination}
\setauthor{Jonas Dorfinger}
Da Triply über eine GitHub Organisation verfügt, ist es naheliegend, dass für webmap ein eigenes Repository angelegt wird.

Um Übersicht über den Projektverlauf zu behalten, ist die Entscheidung aufgrund von internen Vereinbarungen von triply sowie die
Erfahrung des Teams auf GitHub Projects gefallen.
Man kann ein Project Board ganz einfach über die GitHub Website erstellen und dabei auswählen, ob eine Vorlage ausgewählt werden soll.

Es gibt folgende Templates zur Auswahl: ~\cite{github-create-project}

\paragraph{None}
Es wird ein völlig leeres Project Board erstellt, alle Spalten und Einstellungen müssen manuell gemacht werden.

\paragraph{Basic Kanban}
Ein Project Board mit den Spalten \emph{To do}, \emph{In progress} und \emph{Done} wird erstellt.

\paragraph{Automated Kanban}
Es wird ein Basic Kanban Board erstellt, mit der zusätzlichen Funktion von eingebauten Triggern, welche automatisch Issues
und Pull Requests zwischen den Spalten hin und her schieben.

\paragraph{Automated Kanban with Reviews}
Das Template \emph{Automated Kanban with Reviews} erweitert das Automated Kanban Template um 2 weitere Spalten und einen Trigger
, für die Pull Request Reviews.

\paragraph{Bug triage}
Dieses Template wird verwendet, um Bugs zu priorisieren und diese geordnet anzusehen, dabei gibt es folgende Spalten:

\begin{itemize}
    \item To do
    \item High priority
    \item Low priority
    \item Closed
\end{itemize}

\subsection{Issues}
Issues haben die Möglichkeit, die anstehende Arbeit zu dokumentieren und planen.

\cite{github-issues}

\subsection{Automatisierung}
Durch die Verwendung spezieller Keywords in Commit messages oder in einem Kommentar bei einem Issue, kann der Zustand dieses
Issues verändert werden.
Dies geht einher mit der Automatisierung von Project Boards.

\textbf{Keywords:}

\begin{itemize}
    \item close
    \item closes
    \item closed
    \item fix
    \item fixes
    \item fixed
    \item resolve
    \item resolves
    \item resolved
\end{itemize}

\textbf{Verwendung}

\begin{center}
    \centering{<Keyword> <Issue Nummer> <Commit Message>}
\end{center}

\cite{github-issue-automation}


\section{Frontend Framework/Library}
\label{sec:frontend-framework/library}
\input{sections/frontend-framework-library}


\section{Map Frameworks}
\setauthor{Jonas Dorfinger}
Geo-Daten sind sehr komplexe Daten, welche nur sehr schwer und mit viel Erfahrung ohne Visualisierung interpretiert werden können.
Um solche Daten visualiseren zu können werden Map Frameworks benötigt, diese können auf digitalen Karten, die Koordinaten
grafisch darstellen, doch auch interaktive Darstellungen sind möglich.
Drei der bekanntesten Frameworks sind:

\begin{itemize}
    \item Mapbox
    \item Leaflet
    \item Google Maps
\end{itemize}

\subsection{Mapbox}
Mapbox ist ein amerikanisches Unternehmen, welches sich auf Custom-Maps spezialisiert und die Nische stark vergrößert hat.
Dabei geht es um die Darstellung von Geo-Daten auf digitalen Kartensystemen und deren Individualisierung.
Weiters ist Mapbox Contributor zum OpenStreetMap (OSM) Projekt, das ist eine Geo-Datenbank mit Kartendaten und Informationen
für den gesamten Globus.
Große Konzerne wie Amazon, Facebook oder Snapchat setzen auf OpenStreetMap für ihre eigenen Angebote und Services den Kunden gegenüber.
Unternehmen wie Tesla, mit einer eigenen Navigationssoftware verwenden die OSM-Datenbank ebenfalls für ihre eigenen Zwecke~\cite{osm-customers-1, osm-customers-2}.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.25]{pics/austria-mapbox}
    \caption{Österreich mit Bundesländern in Mapbox}
    \label{fig:austria-mapbox}
\end{figure}

\paragraph{Vorteile}
\begin{itemize}
    \item OpenSource (bis Version 2.0.0)~\cite{mapbox-open-source}
    \item Gutes Handling von großen Datensätzen
    \item Individualisierbar
    \item Gute Unterstützung von komplexen Strukturen
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
    \item Ausbaufähige Dokumentation
    \item Kein ausgereifter Angular Wrapper
\end{itemize}

\subsection{Leaflet}
Leaflet ist das laut eigenen Angaben die führende Open-Source JavaScript Library, wenn mobile und interaktive Karten gefordert sind.
Durch die sehr gute API Dokumentation können ganz leicht Geo-Daten auf Karten dargestellt und interaktive Elemente eingebaut werden.
Der Fokus liegt dabei auf den Grundfunktionalitäten, das beinhaltet auch eine Performance Optimierung für fast alle Geräte und Plattformen.
Dank einer leichten Anbindungsmöglichkeit für Plugins, gibt es etliche davon im Internet, die man einfach verwenden kann,
um die Funktionalitäten zu erweitern.
Leaflet wird auch von den ganz großen verwendet: GitHub, Pinterest, Facebook, European Commission, The Washington Post und noch viele mehr.
~\cite{leaflet-doc}

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.4]{pics/austria-leaflet}
    \caption{Österreich mit Bundesländern in Leaflet}
    \label{fig:austria-leaflet}
\end{figure}

\paragraph{Vorteile}
\begin{itemize}
    \item Open-Source (keine Restriktion oder Terms of Service)
    \item Hervorragende Dokumentation
    \item Leichtgewichtig (39KB)
    \item Plugin Support
    \item Angular Wrapper
    \item Bereits von triply in Verwendung
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
    \item Offizielle Dokumentation beinhaltet nur grundlegende Beispiele
    \item Möglicherweise verwenden von GIS Programmen (zum Beispiel QGIS) notwendig, um Informationen aufzubereiten
\end{itemize}

\subsection{Google Maps}
Google Maps ist der Kartendienst von Google und der Kartenprovider mit den meisten Daten, welche zur Verfügung stehen.
OpenStreetMap ist vergleichsweise auf dem Globus nicht deckend, das liegt, jeder kann aber Daten oder Orte beisteuern.
Google Maps hingegen, hat Daten bis in jede noch so kleine Straße, das ermöglicht eine sehr gute Informationslage.
In Kombination mit Places API und der Maps images API kann niemand mit Google mithalten.
Das liegt auch daran, dass Google mehr als Maps betreut und deshalb viel mehr Möglichkeiten als zum Beispiel OpenStreetMap hat.
Der wohl größte Nachteil liegt an der kostenpflichtigen Nutzung ab einer gewissen Nutzerzahl.
Ab 1000 Anfragen pro Monat ist Google Maps nicht mehr gratis und damit frei zu nutzen~\cite{google-maps-vs-osm}.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.2]{pics/austria-googlemaps}
    \caption{Österreich mit Bundesländern in Google Maps}
    \label{fig:austria-googlemaps}
\end{figure}

\paragraph{Vorteile}
\begin{itemize}
    \item Google Ökosystem
    \item hohe Abdeckung des Globus
    \item Angular Wrapper
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
    \item Kann kostenpflichtig werden
    \item Terms of Use und Restriktionen
    \item Google Logo immer sichtbar
    \item Farbschema kann kaum verändert werden.
\end{itemize}

\cleardoublepage

\subsection{Performance im Vergleich}
Um eine Wahl auf ein bestimmtes Framework treffen zu können, wurden mithilfe der Chrome-Developer-Tools die Ladezeiten
unter bestimmten Voraussetzungen der einzelnen Frameworks getestet.
In diesen Tools gibt es die Möglichkeit zwischen einem schnellem (fast), einem mittel-schnellem (mid-tier) und einem
langsamen (low-end) Gerät zu wählen.
Dadurch änderten sich die Ladezeiten teils sehr drastisch.
Folgende Ergebnisse wurden bei dem Versuch erhalten:

\begin{table}[hbt!]
    \centering
    \begin{tabular}{llll}
        & \textbf{Leaflet} & \textbf{Mapbox} & \textbf{Google Maps} \\
        \textbf{low-end device}  & 132s             & 138s            & 192s                 \\
        \textbf{mid-tier device} & 39,5s            & 41,69s          & 56,12s               \\
        \textbf{fast device}     & 1,2s             & 3,9s            & 3,23s
    \end{tabular}\label{tab:map-framework-table}
\end{table}

Aufgrund der oben genannten Vor- und Nachteilen, sowie persönlichen Erfahrungen der Entwickler und nach Absprache mit der
Betreuerfirma ist die Wahl schlussendlich auf Leaflet in Kombination mit einer Mapbox Tile-layer gefallen.
Tile-layers bestimmen die Darstellung der Karte an sich und werden von externen Servern direkt für den aktuell zu sehenden Bereich angefordert.

\cleardoublepage

\section{Static Site Generators}
\setauthor{Sebastian Scholl}

\subsection{Next.js}

\subsection{Jekyll}

\subsection{Scully}


\section{Deployment Pipeline}
\setauthor{Sebastian Scholl}
Nach dem Download des generierten Projekts sollte die Möglichkeit bestehen,
kleine Änderungen daran vorzunehmen und es dann schnell und einfach auf einen
Server zu deployen. Der Server ist dabei entweder eine Linux Virtual Machine
oder eine \textit{Firebase Hosting} Instanz.
Dazu gab es mehrere Ansätze: Ist das Projekt ein Git-Repository, kann eine
Automatisierungssoftware, wie Jenkins oder GitHub Actions verwendet werden,
die bei jedem \textit{Push}-Event das Projekt buildet und auf den Server
deployed. Die zweite Möglichkeit ist ein Node.js Skript, das im Projekt
enthalten ist und von der Kommandozeile aus ausgeführt wird.

\subsection{Jenkins}
Jenkins ist ein Open-Source Automatisierungsserver. Das Projekt wird in
Java entwickelt und kann mit Hilfe von Plugins an spezifische Anforderungen
angepasst werden.
Der Server wird vor Allem zur Automatisierung von Aufgaben, wie das Builden,
Testen und Deployen von Softwareprojekten genutzt.
Jenkins muss selbst gehosted werden. Dazu wird ein offizielles Docker Image
im Docker Hub bereitgestellt.
Die Konfiguration einer Pipeline wird in einem \textit{Jenkinsfile} vorgenommen,
das sich im Git-Repository befindet.
Um die Dateien zur Virtual Machine zu senden, wurde das Plugin \textit{Publish Over SSH}
verwendet. Für das Deployen zu \textit{Firebase Hosting} steht kein Plugin zur
Verfügung. Stattdessen wurde auf die \textit{Firebase CLI} zurückgegriffen.
Ein großer Nachteil von Jenkins war, dass für jedes Projekt erst ein GitHub
Repository und eine neue Pipeline im Web-Interface von Jenkins erstellt werden
musste, bevor es automatisch deployed werden konnte.

% TODO: SSH-Configuration und Firebase Token

% https://wiki.eclipse.org/Jenkins#About_Jenkins, 13.3.
% https://github.com/jenkinsci/jenkins, 13.3.
% https://hub.docker.com/r/jenkins/jenkins, 13.3.
% https://www.jenkins.io/doc/book/pipeline/jenkinsfile/, 13.3.
% https://www.jenkins.io/doc/pipeline/steps/publish-over-ssh/, 13.3.
% https://firebase.google.com/docs/cli/, 13.3.

\subsection{GitHub Actions}
GitHub Actions ist eine Automatisierungssoftware, die von GitHub zur Verfügung
gestellt wird. Im Gegensatz zu Jenkins werden die Server dabei von GitHub gehosted.
Die Konfiguration von sogenannten Actions wird in \textit{YAML}-Dateien im
Repository vorgenommen.
Auch in GitHub Actions können Plugins verwendet werden, um verschiedenste Aufgaben
zu automatisieren.
Sowohl für das Deployen auf eine Virtual Machine, als auch zu \textit{Firebase Hosting}
stehen Plugins zur Verfügung, was die Konfiguration einfacher als bei Jenkins macht.
Wie auch bei einer Jenkins Pipeline muss für jedes Projekt jedoch auch beim
Ansatz mit GitHub Actions ein GitHub Repository erstellt werden.

% TODO: Secrets

% https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions, 13.3.
% https://github.com/easingthemes/ssh-deploy, 13.3.
% https://github.com/FirebaseExtended/action-hosting-deploy, 13.3.


\section{Backend}
\setauthor{Sebastian Scholl}

\subsection{JavaScript}

\subsection{Typescript}


\section{Webserver}
\setauthor{Sebastian Scholl}


\section{Reverse Proxy}
\setauthor{Sebastian Scholl}


\section{Containerization}
\setauthor{Sebastian Scholl}

\subsection{Docker}

\subsection{Docker Compose}